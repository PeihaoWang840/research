import numpy as np
import pandas as pd

# 参数
b0 = 500  # 距离衰减基准
bM = 5   # 节点重合度基准
r = 500   # 节点影响区域半径
M = 30    # 需要新增的策略点个数
pop_size = 50  # 种群大小
generations = 100  # 遗传算法的迭代次数
alpha1 = 0.5  # f1 的权重
alpha2 = 0.5  # f2 的权重

# 读取现有策略点数据
existing_points_path = r"D:\冷源.xlsx"
existing_data = pd.read_excel(existing_points_path)
existing_x_coords = existing_data['X'].values
existing_y_coords = existing_data['Y'].values
existing_n = len(existing_x_coords)  # 现有策略点的数量

# 读取解空间数据（用于选择新增策略点）
solution_space_path = r"D:\解空间冷源缓冲1000M.xlsx"
solution_space_data = pd.read_excel(solution_space_path)
solution_space_x_coords = solution_space_data['X'].values
solution_space_y_coords = solution_space_data['Y'].values

# 读取研究范围数据
research_space_path = r"D:\研究范围.xlsx"
research_space_data = pd.read_excel(research_space_path)
research_space_x_coords = research_space_data['X'].values
research_space_y_coords = research_space_data['Y'].values

# 计算连通性 f1 的函数，现有策略点和新增策略点都需要计算
def f1_calc(all_x_coords, all_y_coords, b0, bM):
    M = len(all_x_coords)
    f1 = 0
    for i in range(M):
        for j in range(i + 1, M):
            d_ij = np.sqrt((all_x_coords[i] - all_x_coords[j])**2 + (all_y_coords[i] - all_y_coords[j])**2)
            decay_value = np.exp(-d_ij **2/ b0)
            f1 += decay_value / bM
            # # 打印每对点的距离和衰减值
            # print(f"距离 d_ij: {d_ij}, 衰减值: {decay_value}")
    return f1

# 计算覆盖率 f2 的函数
def f2_calc(all_x_coords, all_y_coords, research_space_x_coords, research_space_y_coords, c):
    total_points = len(research_space_x_coords)
    covered_points = 0
    for i in range(total_points):
        for j in range(len(all_x_coords)):
            dist_squared = (research_space_x_coords[i] - all_x_coords[j])**2 + (research_space_y_coords[i] - all_y_coords[j])**2
            if dist_squared <= c**2:
                covered_points += 1
                break
    coverage_percentage = (covered_points / total_points) * 1
    return coverage_percentage


# 计算总适应度的函数
def total_fitness(f1, f2, alpha1=0.5, alpha2=0.5):
    return alpha1 * f1 + alpha2 * f2

# 初始化种群：从解空间中随机选择 M 个新增策略点
def initialize_population(M, pop_size):
    population = []
    for _ in range(pop_size):
        selected_indices = np.random.choice(len(solution_space_x_coords), M, replace=False)
        individual = np.column_stack((solution_space_x_coords[selected_indices], solution_space_y_coords[selected_indices]))
        population.append(individual)
    return np.array(population)

# 变异函数
def mutate(population, mutation_rate=0.1):
    for individual in population:
        if np.random.rand() < mutation_rate:
            i = np.random.randint(len(individual))
            individual[i][0] = np.random.choice(solution_space_x_coords)
            individual[i][1] = np.random.choice(solution_space_y_coords)
    return population

# 交叉函数
def crossover(parent1, parent2):
    crossover_point = np.random.randint(1, len(parent1) - 1)
    child1 = np.vstack((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.vstack((parent2[:crossover_point], parent1[crossover_point:]))
    return child1, child2

# 选择父母代函数：根据适应度选择最优个体
def select_parents(population, fitnesses):
    parents_idx = np.argsort(fitnesses)[-2:]
    return population[parents_idx[0]], population[parents_idx[1]]

# 遗传算法主循环
def genetic_algorithm(M, generations=100, pop_size=50):
    population = initialize_population(M, pop_size)
    for gen in range(generations):
        fitnesses = []
        for individual in population:
            # 结合现有策略点和新增策略点
            all_x_coords = np.concatenate((existing_x_coords, individual[:, 0]))
            all_y_coords = np.concatenate((existing_y_coords, individual[:, 1]))

            # 计算适应度：f1 和 f2 都基于所有策略点（包括现有点和新增点）
            f1 = f1_calc(all_x_coords, all_y_coords, b0, bM)
            f2 = f2_calc(all_x_coords, all_y_coords, solution_space_x_coords, solution_space_y_coords, r)
            fitness = total_fitness(f1, f2, alpha1, alpha2)
            fitnesses.append(fitness)

        # 选择最优的父母代
        parent1, parent2 = select_parents(population, fitnesses)

        # 生成新一代种群
        new_population = []
        for _ in range(pop_size // 2):
            child1, child2 = crossover(parent1, parent2)
            new_population.append(child1)
            new_population.append(child2)

        # 进行变异
        population = mutate(np.array(new_population))

    # 返回适应度最高的个体
    best_individual = population[np.argmax(fitnesses)]
    return best_individual, max(fitnesses)

# 运行遗传算法，选择 M 个新增策略点
best_individual, best_fitness = genetic_algorithm(M, generations, pop_size)

# 将现有策略点与新增策略点组合起来
final_x_coords = np.concatenate((existing_x_coords, best_individual[:, 0]))
final_y_coords = np.concatenate((existing_y_coords, best_individual[:, 1]))

# 计算最终策略点网络的连通性 f1 和覆盖率 f2
final_f1 = f1_calc(final_x_coords, final_y_coords, b0, bM)
final_f2 = f2_calc(final_x_coords, final_y_coords, solution_space_x_coords, solution_space_y_coords, r)

# 输出最终的 f1 和 f2 以及总适应度
print("最终策略点网络的连通性 f1:", final_f1)
print("最终策略点网络的覆盖率 f2:", final_f2)
print("最终的总适应度:", alpha1 * final_f1 + alpha2 * final_f2)

# 输出结果到 Excel 文件
output_path = r"D:\output-test30-B500.xlsx"
output_df = pd.DataFrame({'X': best_individual[:, 0], 'Y': best_individual[:, 1]})
output_df.to_excel(output_path, index=False)

print("新增策略点（x, y）坐标已写入:", output_path)
