import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.spatial.distance import cdist
from scipy.optimize import differential_evolution

# 读取数据
try:
    existing_data = pd.read_excel(r"D:\冷源.xlsx")
    existing_x_coords = existing_data['X'].values
    existing_y_coords = existing_data['Y'].values

    solution_space_data = pd.read_excel(r"D:\解空间.xlsx")
    solution_space_coords = np.column_stack((solution_space_data['X'].values, solution_space_data['Y'].values))

    df = pd.read_excel(r"D:\研究范围_去除660M缓冲.xlsx")
    research_x_coords = df['X'].values
    research_y_coords = df['Y'].values
except Exception as e:
    print(f"数据读取失败: {e}")
    exit()

# 参数
M = 60  
r = 660  
r_squared = r ** 2  
b_D = r * 3000  
b_M = len(existing_x_coords)  
alpha1 = 0.5  
alpha2 = 0.5  

# 计算 f1（网络连接性）
def f1_calc(all_x_coords, all_y_coords, r, b_D, bn):
    if bn <= 1:
        return 0  
    coords = np.column_stack((all_x_coords, all_y_coords))
    dist_squared = cdist(coords, coords, 'sqeuclidean')
    np.fill_diagonal(dist_squared, np.inf)
    connectivity = np.exp(-dist_squared / max(b_D, 1e-5))
    return 2 * connectivity.sum() / ((bn - 1) * bn)

# 计算 f2（覆盖率）
def f2_calc(new_x_coords, new_y_coords, research_x_coords, research_y_coords, r_squared):
    new_coords = np.column_stack((new_x_coords, new_y_coords))
    research_coords = np.column_stack((research_x_coords, research_y_coords))
    dist_squared = cdist(research_coords, new_coords, 'sqeuclidean')
    covered = np.any(dist_squared <= r_squared, axis=1)
    return np.sum(covered) / len(research_coords)

# 计算总适应度
def total_fitness(solution):
    new_x_coords = solution[:M]
    new_y_coords = solution[M:]
    all_x_coords = np.concatenate((existing_x_coords, new_x_coords))
    all_y_coords = np.concatenate((existing_y_coords, new_y_coords))
    f1 = f1_calc(all_x_coords, all_y_coords, r, b_D, b_M + M)
    f2 = f2_calc(new_x_coords, new_y_coords, research_x_coords, research_y_coords, r_squared)
    return -(alpha1 * f1 + alpha2 * f2)  # 由于 DE 是最小化优化问题，因此取负值

# 设定 DE 参数
bounds = [(np.min(solution_space_coords[:, 0]), np.max(solution_space_coords[:, 0]))] * M + \
         [(np.min(solution_space_coords[:, 1]), np.max(solution_space_coords[:, 1]))] * M

result = differential_evolution(total_fitness, bounds, strategy='best1bin', popsize=50, mutation=(0.5, 1), 
                                recombination=0.7, maxiter=100, disp=True)

best_solution = result.x
best_x_coords = best_solution[:M]
best_y_coords = best_solution[M:]

# 计算最优解对应的 f1 和 f2
f1_best = f1_calc(np.concatenate((existing_x_coords, best_x_coords)),
                  np.concatenate((existing_y_coords, best_y_coords)),
                  r, b_D, b_M + M)
f2_best = f2_calc(best_x_coords, best_y_coords, research_x_coords, research_y_coords, r_squared)

g_best_fitness = -(result.fun)
print(f"最优解的适应度值: {g_best_fitness}")

# 记录最终解
pareto_data = [[f1_best, f2_best, i+1, x, y] for i, (x, y) in enumerate(zip(best_x_coords, best_y_coords))]
pareto_df = pd.DataFrame(pareto_data, columns=['f1', 'f2', '点序号', 'X', 'Y'])
pareto_df.to_excel(r'D:\pareto_front_de.xlsx', index=False)
print("完整的帕累托前沿解已保存到: D:\pareto_front_de.xlsx")

# 绘制帕累托前沿
plt.figure(figsize=(8, 6))
plt.scatter(f1_best, f2_best, color="red", label="最优解", edgecolors="black", s=50)
plt.xlabel("f1 (网络连接性)")
plt.ylabel("f2 (覆盖率)")
plt.title("帕累托前沿图 (DE)")
plt.legend()
plt.grid()
plt.savefig(r'D:\pareto_front_de.png', dpi=300, bbox_inches='tight')
plt.show()
print("帕累托前沿图已保存到: D:\pareto_front_de.png")
