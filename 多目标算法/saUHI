import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.spatial.distance import cdist

# 读取数据（保持不变）
try:
    existing_data = pd.read_excel(r"D:\冷源.xlsx")
    existing_x_coords = existing_data['X'].values
    existing_y_coords = existing_data['Y'].values

    solution_space_data = pd.read_excel(r"D:\解空间.xlsx")
    solution_space_coords = np.column_stack((solution_space_data['X'].values, solution_space_data['Y'].values))

    df = pd.read_excel(r"D:\研究范围_去除660M缓冲.xlsx")
    research_x_coords = df['X'].values
    research_y_coords = df['Y'].values
except Exception as e:
    print(f"数据读取失败: {e}")
    exit()

# 参数设置
M = 60  
r = 660  
r_squared = r ** 2  
b_D = r * 3000  
b_M = len(existing_x_coords)  
alpha1 = 0.5  
alpha2 = 0.5  
num_iterations = 100  # 迭代次数
T = 1000  # 初始温度
T_min = 1  # 最小温度
cooling_rate = 0.95  # 冷却率

# 目标函数
def f1_calc(all_x_coords, all_y_coords, r, b_D, bn):
    if bn <= 1:
        return 0  
    coords = np.column_stack((all_x_coords, all_y_coords))
    dist_squared = cdist(coords, coords, 'sqeuclidean')
    np.fill_diagonal(dist_squared, np.inf)
    connectivity = np.exp(-dist_squared / max(b_D, 1e-5))
    return 2 * connectivity.sum() / ((bn - 1) * bn)

def f2_calc(new_x_coords, new_y_coords, research_x_coords, research_y_coords, r_squared):
    new_coords = np.column_stack((new_x_coords, new_y_coords))
    research_coords = np.column_stack((research_x_coords, research_y_coords))
    dist_squared = cdist(research_coords, new_coords, 'sqeuclidean')
    covered = np.any(dist_squared <= r_squared, axis=1)
    return np.sum(covered) / len(research_coords)

def total_fitness(f1, f2, alpha1, alpha2):
    return alpha1 * f1 + alpha2 * f2

# 初始化解
current_solution = solution_space_coords[np.random.choice(len(solution_space_coords), M, replace=False)]
current_f1 = f1_calc(np.concatenate((existing_x_coords, current_solution[:, 0])),
                     np.concatenate((existing_y_coords, current_solution[:, 1])), r, b_D, b_M + M)
current_f2 = f2_calc(current_solution[:, 0], current_solution[:, 1], research_x_coords, research_y_coords, r_squared)
current_fitness = total_fitness(current_f1, current_f2, alpha1, alpha2)

best_solution = np.copy(current_solution)
best_fitness = current_fitness

# SA 迭代优化
T_current = T
while T_current > T_min:
    for _ in range(num_iterations):
        new_solution = np.copy(current_solution)
        swap_idx = np.random.randint(M)  # 随机选择一个点进行扰动
        new_solution[swap_idx] = solution_space_coords[np.random.choice(len(solution_space_coords))]
        
        new_f1 = f1_calc(np.concatenate((existing_x_coords, new_solution[:, 0])),
                         np.concatenate((existing_y_coords, new_solution[:, 1])), r, b_D, b_M + M)
        new_f2 = f2_calc(new_solution[:, 0], new_solution[:, 1], research_x_coords, research_y_coords, r_squared)
        new_fitness = total_fitness(new_f1, new_f2, alpha1, alpha2)
        
        delta_fitness = new_fitness - current_fitness
        if delta_fitness > 0 or np.exp(delta_fitness / T_current) > np.random.rand():
            current_solution = new_solution
            current_fitness = new_fitness
            if current_fitness > best_fitness:
                best_solution = np.copy(current_solution)
                best_fitness = current_fitness
    
    T_current *= cooling_rate

print(f"最优解的适应度值: {best_fitness}")

# 计算帕累托前沿（保持不变）
pareto_front = []
pareto_solutions = []
for i in range(num_iterations):
    dominated = False
    for j in range(num_iterations):
        if (j != i and best_fitness >= current_fitness and best_fitness > current_fitness):
            dominated = True
            break
    if not dominated:
        pareto_front.append(best_fitness)
        pareto_solutions.append(best_solution)

# 保存并绘制帕累托前沿（保持不变）
pd.DataFrame(pareto_front).to_excel(r'D:\pareto_front_sa.xlsx', index=False)
plt.scatter(range(len(pareto_front)), pareto_front, color="red", label="帕累托前沿")
plt.xlabel("解序号")
plt.ylabel("适应度")
plt.legend()
plt.grid()
plt.savefig(r'D:\pareto_front_sa.png', dpi=300)
plt.show()
